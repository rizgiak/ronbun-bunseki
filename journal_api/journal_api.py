from journal_api import arxiv_api
from journal_api import crossref_api
from journal_api import googlebook_api
from journal_api import semanticscholar_api
import yaml
import pandas as pd
import logging
import logging.config

with open("settings.yaml") as yaml_file:
    settings = yaml.safe_load(yaml_file)

with open('logging_config.yaml', 'r') as config_file:
    log_config = yaml.safe_load(config_file)

logging.config.dictConfig(log_config)

class JournalAPI:
    def __init__(self):
        self._max_pos = 3
        self._df = None

    def reset_df(self):
        self._df = None
    
    def get_df(self):
        return self._df

    def _dic_library(self, title, pos, year = 2010, find_references = True, skip_unknown_year = False):
        res = None
        if pos == 1:
            res = crossref_api.search(title, year, find_references, skip_unknown_year)
        elif pos == 2:
            # TODO: add proxy handler
            if not settings["USE_PROXY"]:
                res = arxiv_api.search(title, year)    
        elif pos == 3:
            res = googlebook_api.search(title, year)
        else:
            res = semanticscholar_api.search(title, year, filter_year_for_all=False, skip_unknown_year=skip_unknown_year) 
        return res

    def _remake_result(self, result = None, pos = 0, year = 2010, find_references = True, skip_unknown_year = False):
        if (result == None):
            return None
        dic = ["abstract", "year", "fieldsOfStudy", "authors", "references"]
        l   = [result[dic[0]] == "", result[dic[1]] == "", result[dic[2]] == "", len(result[dic[3]]) == 0, result[dic[4]] != -1 and len(result[dic[4]]) == 0]

        if any(l): # data not completed
            logging.debug(f"journal_api._remake_result: l={l}")
            for i in range(pos + 1, self._max_pos + 1):
                rc = self._dic_library(result["title"], pos = i, year = year, find_references = find_references, skip_unknown_year=skip_unknown_year)
                if self._year_limitation(rc, year): # year limitation
                    logging.debug(f"journal_api._remake_result: Year limitation. year={rc['year']}, start_year={rc}")
                    return None
                if rc != None:
                    r = [rc[dic[0]] == "", rc[dic[1]] == "", rc[dic[2]] == "", len(rc[dic[3]]) == 0, rc[dic[4]] != -1 and len(rc[dic[4]]) == 0]
                    for index, value in enumerate(l):
                        if(value == True and r[index] == False):
                            l[index] = False
                            result[dic[index]] = rc[dic[index]]
                    if not any(l): # if [False, False, False, False]
                        break

        return result

    def _fix_references(self, result, year):
        if (result == None):
            return None
        
        if len(result["references"]) > 0:
            refs = []
            for ti in (result["references"]):
                for i in range(self._max_pos + 1):
                    res = self._dic_library(ti, i, year, find_references = False, skip_unknown_year = True)
                    if(res != None):
                        if res["year"] != "" and res["year"] >= year:
                            refs.append(ti)
                        break;
            result["references"] = refs
        return result

    def _year_limitation(self, res, year):
        if (res != None and res["year"] != "" and res["year"] < year):
            return True
        return False

    def search(self, title, start_year = 2010, find_references = True, fix_references = True, skip_unknown_year = False):
        """
        search\n
        Parameters:\n
        title = title of the paper\n
        start_year = starting year to search\n
        find_references = some of references generated by crossref are DOI, [True] to find the title by its DOI (it will take a more time)\n
        fix_references = some of references are miswritten. [True] to confirm it (it will take a more time)\n
        skip_unknown_year = if the year of the references are '' or unknown, [True] will skip the reference
        """
        res = None
        for i in range(self._max_pos + 1):
            res = self._dic_library(title, i, start_year, find_references, skip_unknown_year)
            if self._year_limitation(res, start_year): # year limitation
                logging.debug(f"journal_api.search: _dic_library, Year limitation. year={res['year']}, start_year={start_year}")
                return None
            res = self._remake_result(result = res, pos = i, year = start_year, find_references = find_references, skip_unknown_year=skip_unknown_year)
            if fix_references:
                res = self._fix_references(res, start_year)
            if(res != None):
                break;
        return res
    

    def _source_target(self, source, target):
        ret = pd.DataFrame(columns=["source", "target"])
        for t in target:
            ret = ret.append({"source": source, "target": t}, ignore_index=True)
        return ret
    

    def source_target_generator(self, title, title_list, level = 1, start_year = 2017, fix_references = False, skip_unknown_year = False):
        ret = pd.DataFrame(columns=["source", "target"])
        if(level > 0):
            logging.info(f"source_target_generator: level={level}, len={len(title_list)}, title={title}")
            for index, title in enumerate(title_list):
                logging.info(f"source_target_generator: [{level}]({index+1}/{len(title_list)}) title={title}")
                src = self.search(title, start_year, find_references=True, fix_references=fix_references, skip_unknown_year=True)
                if src != None:
                    if self._df is None or self._df.empty:
                        self._df = pd.DataFrame([src])
                    else:
                        matching_rows = self._df[(self._df["title"] == src["title"])]
                        if matching_rows.empty:
                            new_row = pd.Series(src)
                            self._df = self._df.append(new_row, ignore_index=True)
                        else:
                            logging.debug(f"source_target_generator: Title already exists. title={src['title']}")
                    
                    if src["references"] != -1: # if conditional for references below start year
                        st = self._source_target(src["title"],src["references"])
                        ret = pd.concat([ret, st], ignore_index=True)
                        lv = level - 1
                        if lv == 1:
                            ret = pd.concat([ret, self.source_target_generator(src["title"], src["references"], lv, start_year)], ignore_index=True)
                        else:
                            ret = pd.concat([ret, self.source_target_generator(src["title"], src["references"], lv, start_year, fix_references)], ignore_index=True)
                
        return ret

